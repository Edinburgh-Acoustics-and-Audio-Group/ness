/*
 * NeSS Framework Code
 *
 * Copyright (c) The University of Edinburgh, 2014-2016. All rights reserved.
 */

#include "ScoreParserXML.h"
#include "Logger.h"
#include "InputWav.h"
#include "Component.h"
#include "GlobalSettings.h"

#ifndef GUITAR_ONLY
#include "BrassInstrument.h"
#include "InputValve.h"
#include "InputLips.h"
#endif

#ifndef BRASS_ONLY
#include "InputStrike.h"
#include "InputPluck.h"
#include "GuitarString.h"
#ifndef GUITAR_ONLY
#include "BowedString.h"
#include "InputBow.h"
#include "Fretboard.h"
#include "InputModalStrike.h"
#include "InputModalSine.h"
#endif
#endif

#include <iostream>
#include <sstream>
#include <cctype>
#include <cstring>
#include <vector>
using namespace std;

ScoreParserXML::ScoreParserXML(string filename) : ScoreParser(filename)
{
}

ScoreParserXML::~ScoreParserXML()
{
}

static void errorHandler(void *ctx, const char *msg, ...)
{
    logMessage(3, "Score file is not valid XML");
}

static void structuredErrorHandler(void *ctx, const xmlError *data)
{
    logMessage(3, "Score file is not valid XML");
}

bool ScoreParserXML::parse(Instrument *instrument)
{
    xmlNodePtr node;
    bool success = true;

    this->instrument = instrument;

    // suppress the error messages generated by libxml2 and use our own instead
    xmlSetGenericErrorFunc(NULL, errorHandler);
    xmlSetStructuredErrorFunc(NULL, (xmlStructuredErrorFunc)structuredErrorHandler);

    doc = xmlParseFile(filename.c_str());
    if (doc == NULL) {
	logMessage(1, "Failed to parse score file as XML");
	return false;
    }

    // check for correct root element
    node = xmlDocGetRootElement(doc);
    if (node == NULL) {
	logMessage(1, "XML document is empty");
	xmlFreeDoc(doc);
	return false;
    }

    if (xmlStrcmp(node->name, (const xmlChar *)"score")) {
	logMessage(1, "Expected score node at root of XML file");
	xmlFreeDoc(doc);
	return false;
    }

    // now loop over children of the root element
    node = node->xmlChildrenNode;
    while ((node != NULL) && (success)) {

	if (!xmlStrcmp(node->name, (const xmlChar *)"duration")) {
	    // ignore, already done
	}
	else if (!xmlStrcmp(node->name, (const xmlChar *)"highpass")) {
	    char *hp = parseString(node);
	    if (!strcmp(hp, "on")) {
		GlobalSettings::getInstance()->setHighPassOn(true);
	    }
	    free(hp);
	}
	else if (!xmlStrcmp(node->name, (const xmlChar *)"wav")) {
	    if (!parseWav(node)) {
		success = false;
	    }
	}
#ifndef BRASS_ONLY
	else if (!xmlStrcmp(node->name, (const xmlChar *)"strike")) {
	    if (!parseStrike(node, false)) {
		success = false;
	    }
	}
	else if (!xmlStrcmp(node->name, (const xmlChar *)"pluck")) {
	    if (!parseStrike(node, true)) {
		success = false;
	    }
	}
#ifndef GUITAR_ONLY
	else if (!xmlStrcmp(node->name, (const xmlChar *)"bow")) {
	    if (!parseBow(node)) {
		success = false;
	    }
	}
	else if (!xmlStrcmp(node->name, (const xmlChar *)"sine")) {
	    if (!parseSine(node)) {
		success = false;
	    }
	}
#endif
	else if (!xmlStrcmp(node->name, (const xmlChar *)"finger")) {
	    if (!parseFinger(node)) {
		success = false;
	    }
	}
#endif
#ifndef GUITAR_ONLY
	else if (!xmlStrcmp(node->name, (const xmlChar *)"lips")) {
	    if (!parseLips(node)) {
		success = false;
	    }
	}
	else if (!xmlStrcmp(node->name, (const xmlChar *)"valve")) {
	    if (!parseValve(node)) {
		success = false;
	    }
	}
#endif
	else if (xmlStrcmp(node->name, (const xmlChar *)"text")) {
	    logMessage(1, "Unrecognised element %s in score file",
		       node->name);
	}

	node = node->next;
    }

    xmlFreeDoc(doc);

    return success;
}

double ScoreParserXML::getDuration()
{
    xmlNodePtr node;
    double duration = -1.0;

    // suppress the error messages generated by libxml2 and use our own instead
    xmlSetGenericErrorFunc(NULL, errorHandler);
    xmlSetStructuredErrorFunc(NULL, (xmlStructuredErrorFunc)structuredErrorHandler);

    doc = xmlParseFile(filename.c_str());
    if (doc == NULL) {
	logMessage(1, "Failed to parse score file as XML");
	return -1.0;
    }

    // check for correct root element
    node = xmlDocGetRootElement(doc);
    if (node == NULL) {
	logMessage(1, "XML document is empty");
	xmlFreeDoc(doc);
	return -1.0;
    }

    if (xmlStrcmp(node->name, (const xmlChar *)"score")) {
	logMessage(1, "Expected score node at root of XML file");
	xmlFreeDoc(doc);
	return -1.0;
    }

    // now loop over children of the root element
    node = node->xmlChildrenNode;
    while (node != NULL) {

	if (!xmlStrcmp(node->name, (const xmlChar *)"duration")) {
	    if (!parseDouble(node, &duration)) {
		logMessage(5, "Invalid duration in score file");
		return -1.0;
	    }
	}

	node = node->next;
    }

    xmlFreeDoc(doc);

    return duration;
}

// a bool attribute is actually stored as an int, because a negative value
// means "fallback to default"
#define BOOL_ATTRIBUTE(tname, attrname, var) \
    { \
        xmlChar *xattr = xmlGetProp(node, (const xmlChar *)attrname); \
	if (xattr) { \
	    if (!xmlStrcmp(xattr, (const xmlChar *)"true")) { \
	        var = 1; \
	    } \
	    else if (!xmlStrcmp(xattr, (const xmlChar *)"false")) { \
	        var = 0; \
	    } \
	    else { \
	        logMessage(5, "Invalid value '%s' for %s %s attribute", xattr, \
			   tname, attrname);				\
		xmlFree(xattr);						\
		return false;						\
	    } \
	    xmlFree(xattr); \
	}		    \
    } \


// begin property processing loop for children of xmlNodePtr node
#define BEGIN_PROPERTIES(tname) \
    char *component = NULL; \
    char *filename = NULL; \
    bool recognised = false; \
    xmlNodePtr child = node->xmlChildrenNode; \
    const char *tpname = tname; \
    while (child != NULL) { \


// end propery processing loop
#define END_PROPERTIES \
        if (!recognised) { \
	    if (xmlStrcmp(child->name, (const xmlChar *)"text")) { \
	        logMessage(1, "Unrecognised element %s in %s definition", \
			   child->name, tpname); \
            } \
	} \
        child = child->next; \
    } \


#define DOUBLE_PROPERTY(propname, var) \
    if (!xmlStrcmp(child->name, (const xmlChar *)propname)) { \
        if (!parseDouble(child, &var)) { \
	    logMessage(5, "Invalid %s value in %s definition", propname, tpname); \
	    if (filename) free(filename); \
	    if (component) free(component); \
	    return false; \
	} \
	recognised = true; \
    } \


#define STRING_PROPERTY(propname, var) \
    if (!xmlStrcmp(child->name, (const xmlChar *)propname)) { \
        var = parseString(child); \
	recognised = true; \
    } \


#define BREAKPOINT_PROPERTY(propname, var, tag1, tag2) \
    if (!xmlStrcmp(child->name, (const xmlChar *)propname)) { \
	if (!parseBreakpointFunction(child, tag1, tag2, &var)) { \
	    if (component) free(component); \
	    return false; \
	} \
        recognised = true;					      \
    } \


#ifndef BRASS_ONLY

bool ScoreParserXML::parseStrike(xmlNodePtr node, bool isPluck)
{
    double x = -1.0, y = 0.0, z = 0.0;
    double startTime = -1.0, duration = -1.0, amplitude = -1.0;
    int interpolated = -1, negated = -1;
    const char *itname = isPluck ? "pluck" : "strike";
	
    // allow interpolation and negation to be configured from XML
    BOOL_ATTRIBUTE(itname, "interpolated", interpolated);
    BOOL_ATTRIBUTE(itname, "negated", negated);

    BEGIN_PROPERTIES(itname);
    STRING_PROPERTY("component", component);
    DOUBLE_PROPERTY("x", x);
    DOUBLE_PROPERTY("y", y);
    DOUBLE_PROPERTY("z", z);
    DOUBLE_PROPERTY("startTime", startTime);
    DOUBLE_PROPERTY("duration", duration);
    DOUBLE_PROPERTY("amplitude", amplitude);
    END_PROPERTIES;

    // check we got everything we need
    if ((!component) || (x < 0.0) || (startTime < 0.0) || (duration < 0.0) ||
	(amplitude < 0.0)) {
	logMessage(5, "Strike/pluck definition is missing required value");
	if (component) free(component);
	return false;
    }

    // find component
    Component *comp = instrument->getComponentByName(component);
    if (!comp) {
	logMessage(5, "Unrecognised component name %s in strike/pluck definition",
		   component);
	free(component);
	return false;
    }
    free(component);

    // actually create the input
    Input *input;

#ifndef GUITAR_ONLY
    ModalPlate *mp = dynamic_cast<ModalPlate*>(comp);
    if (mp != NULL) {
	input = new InputModalStrike(mp, x, y, startTime, duration, amplitude);
    }
    else {
#endif
	if (!isPluck) {
	    input = new InputStrike(comp, x, y, z, startTime, duration, amplitude,
				    interpolated, negated);
	}
	else {
	    input = new InputPluck(comp, x, y, z, startTime, duration, amplitude,
				   interpolated, negated);
	}
#ifndef GUITAR_ONLY
    }
#endif
    comp->addInput(input);

    return true;
}

bool ScoreParserXML::parseFinger(xmlNodePtr node)
{
    double Mf = -1.0, Kf = -1.0, alphaf = -1.0, betaf = -1.0;
    double uf0 = -1.0, vf0 = -1.0;

    vector<double> fingertime, fingerpos, fingerforce;
    double ftime, fpos, fforce;

    // bowed string finger stuff
    double w0 = -1000000000.0, vw0 = -1000000000.0, u0 = -1000000000.0, vu0 = -1000000000.0;
    vector<double> force_w, force_u, vibrato;
    int i;

    BEGIN_PROPERTIES("finger");
    STRING_PROPERTY("component", component);
    DOUBLE_PROPERTY("mass", Mf);
    DOUBLE_PROPERTY("K", Kf);
    DOUBLE_PROPERTY("alpha", alphaf);
    DOUBLE_PROPERTY("beta", betaf);
    DOUBLE_PROPERTY("initialPosition", uf0);
    DOUBLE_PROPERTY("initialVelocity", vf0);

    DOUBLE_PROPERTY("w0", w0);
    DOUBLE_PROPERTY("vw0", vw0);
    DOUBLE_PROPERTY("u0", u0);
    DOUBLE_PROPERTY("vu0", vu0);

    if (!xmlStrcmp(child->name, (const xmlChar *)"gesture")) {
	xmlNodePtr gesture = child->xmlChildrenNode;
	while (gesture != NULL) {
	    if (!xmlStrcmp(gesture->name, (const xmlChar *)"time")) {
		if (!parseDouble(gesture, &ftime)) {
		    logMessage(5, "Invalid time value in finger gesture definition");
		    if (component) free(component);
		    return false;
		}
		fingertime.push_back(ftime);
	    }
	    else if (!xmlStrcmp(gesture->name, (const xmlChar *)"position")) {
		if (!parseDouble(gesture, &fpos)) {
		    logMessage(5, "Invalid position value in finger gesture definition");
		    if (component) free(component);
		    return false;
		}
		fingerpos.push_back(fpos);
	    }
	    else if (!xmlStrcmp(gesture->name, (const xmlChar *)"force")) {
		if (!parseDouble(gesture, &fforce)) {
		    logMessage(5, "Invalid force value in finger gesture definition");
		    if (component) free(component);
		    return false;
		}
		fingerforce.push_back(fforce);
	    }
	    else if (!xmlStrcmp(gesture->name, (const xmlChar *)"force_w")) {
		if (!parseDouble(gesture, &fforce)) {
		    logMessage(5, "Invalid force value in finger gesture definition");
		    if (component) free(component);
		    return false;
		}
		force_w.push_back(fforce);
	    }
	    else if (!xmlStrcmp(gesture->name, (const xmlChar *)"force_u")) {
		if (!parseDouble(gesture, &fforce)) {
		    logMessage(5, "Invalid force value in finger gesture definition");
		    if (component) free(component);
		    return false;
		}
		force_u.push_back(fforce);
	    }
	    else if (xmlStrcmp(gesture->name, (const xmlChar *)"text")) {
		logMessage(1, "Unrecognised element %s in finger gesture definition",
			   gesture->name);
	    }
	    gesture = gesture->next;
	}
	recognised = true;
    }
    if (!xmlStrcmp(child->name, (const xmlChar *)"vibrato")) {
	vector<double> vbt, vet, vrt, va, vf;
	double tmpval;

	xmlNodePtr vibnode = child->xmlChildrenNode;
	while (vibnode != NULL) {
	    if (!xmlStrcmp(vibnode->name, (const xmlChar *)"beginTime")) {
		if (!parseDouble(vibnode, &tmpval)) {
		    logMessage(5, "Invalid beginTime value in finger vibrato definition");
		    if (component) free(component);
		    return false;
		}
		vbt.push_back(tmpval);
	    }
	    else if (!xmlStrcmp(vibnode->name, (const xmlChar *)"endTime")) {
		if (!parseDouble(vibnode, &tmpval)) {
		    logMessage(5, "Invalid endTime value in finger vibrato definition");
		    if (component) free(component);
		    return false;
		}
		vet.push_back(tmpval);
	    }
	    else if (!xmlStrcmp(vibnode->name, (const xmlChar *)"rampTime")) {
		if (!parseDouble(vibnode, &tmpval)) {
		    logMessage(5, "Invalid rampTime value in finger vibrato definition");
		    if (component) free(component);
		    return false;
		}
		vrt.push_back(tmpval);
	    }
	    else if (!xmlStrcmp(vibnode->name, (const xmlChar *)"amplitude")) {
		if (!parseDouble(vibnode, &tmpval)) {
		    logMessage(5, "Invalid amplitude value in finger vibrato definition");
		    if (component) free(component);
		    return false;
		}
		va.push_back(tmpval);
	    }
	    else if (!xmlStrcmp(vibnode->name, (const xmlChar *)"frequency")) {
		if (!parseDouble(vibnode, &tmpval)) {
		    logMessage(5, "Invalid frequency value in finger vibrato definition");
		    if (component) free(component);
		    return false;
		}
		vf.push_back(tmpval);
	    }
	    vibnode = vibnode->next;
	}

	// check vector lengths
	if ((vbt.size() != vet.size()) || (vbt.size() != vrt.size()) ||
	    (vbt.size() != va.size()) || (vbt.size() != vf.size())) {
	    logMessage(5, "Finger vibrato definition is missing elements");
	    if (component) free(component);
	    return false;
	}

	// combine data into single vector
	for (i = 0; i < vbt.size(); i++) {
	    vibrato.push_back(vbt[i]);
	    vibrato.push_back(vet[i]);
	    vibrato.push_back(vrt[i]);
	    vibrato.push_back(va[i]);
	    vibrato.push_back(vf[i]);
	}
	recognised = true;
    }
    END_PROPERTIES;

#ifndef GUITAR_ONLY
    // check for bowed string version
    if (force_w.size() != 0) {
	// check the scalars are OK
	if ((!component) || (w0 < -1000000.0) || (vw0 < -1000000.0) ||
	    (u0 < -1000000.0) || (vu0 < -1000000.0)) {
	    logMessage(5, "Finger definition is missing required value");
	    if (component) free(component);
	    return false;
	}

	// check gestures are complete
	if ((fingertime.size() != fingerpos.size()) ||
	    (fingertime.size() != force_w.size()) ||
	    (fingertime.size() != force_u.size())) {
	    logMessage(5, "Finger gesture is missing values");
	    free(component);
	    return false;
	}

	// find component
	Component *comp = instrument->getComponentByName(component);
	if (!comp) {
	    logMessage(5, "Unrecognised component name %s in finger definition", component);
	    free(component);
	    return false;
	}
	free(component);

	BowedString *bs = dynamic_cast<BowedString*>(comp);
	if (bs == NULL) {
	    logMessage(5, "Finger target is not a bowed string");
	    return false;
	}
	bs->addFinger(w0, vw0, u0, vu0, &fingertime,
		      &fingerpos, &force_w,
		      &force_u, &vibrato);
	return true;
    }
#endif

    // check we got everything we need
    if ((!component) || (uf0 < 0.0) || (vf0 < 0.0)) {
	logMessage(5, "Finger definition is missing required value");
	if (component) free(component);
	return false;
    }

    // check all gestures were complete
    if ((fingertime.size() != fingerpos.size()) || (fingertime.size() != fingerforce.size())) {
	logMessage(5, "Finger gesture is missing values");
	free(component);
	return false;
    }

    // find component
    Component *comp = instrument->getComponentByName(component);
    if (!comp) {
	logMessage(5, "Unrecognised component name %s in finger definition", component);
	free(component);
	return false;
    }
    free(component);

#ifndef GUITAR_ONLY
    // see if it's a Fretboard
    Fretboard *fb = dynamic_cast<Fretboard*>(comp);
    if (fb) {
	if ((Mf < 0.0) || (Kf < 0.0) || (alphaf < 0.0) || (betaf < 0.0)) {
	    logMessage(5, "Finger definition is missing required value");
	    return false;
	}
	fb->setFingerParams(Mf, Kf, alphaf, betaf, uf0, vf0, &fingertime, &fingerpos, &fingerforce);
	return true;
    }
#endif

    // see if it's a GuitarString
    GuitarString *gs = dynamic_cast<GuitarString*>(comp);
    if (gs) {
	gs->addFinger(uf0, vf0, &fingertime, &fingerpos, &fingerforce);
	return true;
    }

    logMessage(5, "Finger inputs can only be used with fretboard or guitar string components");
    return false;
}

#ifndef GUITAR_ONLY
bool ScoreParserXML::parseBow(xmlNodePtr node)
{
    double x = -1.0, y = 0.0, z = 0.0;
    double startTime = -1.0, duration = -1.0, fAmp = -1.0, vAmp = -1.0;
    double friction = -1.0, rampTime = -1.0;

    double w0 = -1000000000.0, vw0 = -1000000000.0, u0 = -10000000000.0, vu0 = -1000000000.0;

    vector<double> bowtime, bowpos, bowforce_w, bowforce_u;
    double btime, bpos, bforcew, bforceu;

    BEGIN_PROPERTIES("bow");
    STRING_PROPERTY("component", component);
    DOUBLE_PROPERTY("x", x);
    DOUBLE_PROPERTY("y", y);
    DOUBLE_PROPERTY("z", z);
    DOUBLE_PROPERTY("startTime", startTime);
    DOUBLE_PROPERTY("duration", duration);
    DOUBLE_PROPERTY("fAmp", fAmp);
    DOUBLE_PROPERTY("vAmp", vAmp);
    DOUBLE_PROPERTY("friction", friction);
    DOUBLE_PROPERTY("rampTime", rampTime);

    DOUBLE_PROPERTY("w0", w0);
    DOUBLE_PROPERTY("vw0", vw0);
    DOUBLE_PROPERTY("u0", u0);
    DOUBLE_PROPERTY("vu0", vu0);
    if (!xmlStrcmp(child->name, (const xmlChar *)"gesture")) {
	xmlNodePtr gesture = child->xmlChildrenNode;
	while (gesture != NULL) {
	    if (!xmlStrcmp(gesture->name, (const xmlChar *)"time")) {
		if (!parseDouble(gesture, &btime)) {
		    logMessage(5, "Invalid time value in bow gesture definition");
		    if (component) free(component);
		    return false;
		}
		bowtime.push_back(btime);
	    }
	    else if (!xmlStrcmp(gesture->name, (const xmlChar *)"position")) {
		if (!parseDouble(gesture, &bpos)) {
		    logMessage(5, "Invalid position value in bow gesture definition");
		    if (component) free(component);
		    return false;
		}
		bowpos.push_back(bpos);
	    }
	    else if (!xmlStrcmp(gesture->name, (const xmlChar *)"force_w")) {
		if (!parseDouble(gesture, &bforcew)) {
		    logMessage(5, "Invalid force_w value in bow gesture definition");
		    if (component) free(component);
		    return false;
		}
		bowforce_w.push_back(bforcew);
	    }
	    else if (!xmlStrcmp(gesture->name, (const xmlChar *)"force_u")) {
		if (!parseDouble(gesture, &bforceu)) {
		    logMessage(5, "Invalid force_u value in bow gesture definition");
		    if (component) free(component);
		    return false;
		}
		bowforce_u.push_back(bforceu);
	    }
	    else if (xmlStrcmp(gesture->name, (const xmlChar *)"text")) {
		logMessage(1, "Unrecognised element %s in bow gesture definition",
			   gesture->name);
	    }
	    gesture = gesture->next;
	}
	recognised = true;
    }
    END_PROPERTIES;


    if (w0 < 0.0) {
	// it's an old-style (Zero code) bow
	// check we got everything we need
	if ((!component) || (x < 0.0) || (startTime < 0.0) || (duration < 0.0) ||
	    (fAmp < 0.0) || (vAmp < 0.0) || (friction < 0.0) || (rampTime < 0.0)) {
	    logMessage(5, "Bow definition is missing required value");
	    if (component) free(component);
	    return false;
	}
	
	// find component
	Component *comp = instrument->getComponentByName(component);
	if (!comp) {
	    logMessage(5, "Unrecognised component name %s in bow definition",
		       component);
	    free(component);
	    return false;
	}
	free(component);
	
	comp->addInput(new InputBow(comp, x, y, z, startTime, duration, fAmp, vAmp,
				    friction, rampTime));
    }
    else {
	// bowed string bow
	if ((!component) || (vw0 < -1000000.0) || (u0 < -1000000.0) || (vu0 < -1000000.0)) {
	    logMessage(5, "Bow definition is missing required value");
	    if (component) free(component);
	    return false;
	}
	if ((bowtime.size() != bowpos.size()) || (bowforce_u.size() != bowforce_w.size()) ||
	    (bowtime.size() != bowforce_w.size())) {
	    logMessage(5, "Bow gesture is missing values");
	    if (component) free(component);
	    return false;
	}

	// find the corresponding component
	Component *comp = instrument->getComponentByName(component);
	if (!comp) {
	    logMessage(5, "Unrecognised component name %s in bow definition", component);
	    free(component);
	    return false;
	}
	free(component);

	// make sure it's a bowed string
	BowedString *bs = dynamic_cast<BowedString*>(comp);
	if (!bs) {
	    logMessage(5, "Bows with gestures can only be used on bowed strings");
	    return false;
	}

	// add the bow
	bs->addBow(w0, vw0, u0, vu0, &bowtime, &bowpos, &bowforce_w, &bowforce_u);
    }
    return true;
}

bool ScoreParserXML::parseSine(xmlNodePtr node)
{
    double time = -1.0, force = -1.0, frequency = -1.0, rampUpTime = -1.0;
    double steadyTime = -1.0, rampDownTime = -1.0, x = -1.0, y = -1.0;

    BEGIN_PROPERTIES("sine input");
    STRING_PROPERTY("component", component);
    DOUBLE_PROPERTY("time", time);
    DOUBLE_PROPERTY("force", force);
    DOUBLE_PROPERTY("frequency", frequency);
    DOUBLE_PROPERTY("rampUpTime", rampUpTime);
    DOUBLE_PROPERTY("steadyTime", steadyTime);
    DOUBLE_PROPERTY("rampDownTime", rampDownTime);
    DOUBLE_PROPERTY("x", x);
    DOUBLE_PROPERTY("y", y);
    END_PROPERTIES;

    // check we got everything we need
    if ((!component) || (time < 0.0) || (force < 0.0) || (frequency < 0.0) ||
	(rampUpTime < 0.0) || (steadyTime < 0.0) || (rampDownTime < 0.0) ||
	(x < 0.0) || (y < 0.0)) {
	logMessage(5, "Sine input definition is missing a required value");
	if (component) free(component);
	return false;
    }

    // find the component
    Component *comp = instrument->getComponentByName(component);
    if (!comp) {
	logMessage(5, "Unrecognised component name %s in sine input definition",
		   component);
	free(component);
	return false;
    }
    free(component);

    // check that it's a modal plate
    ModalPlate *mp = dynamic_cast<ModalPlate*>(comp);
    if (!mp) {
	logMessage(5, "Sine input only supported for modal plates");
	return false;
    }

    // actually create the input
    InputModalSine *input = new InputModalSine(mp, time, force, frequency,
					       rampUpTime, steadyTime,
					       rampDownTime, x, y);
    mp->addInput(input);
    return true;
}

#endif

#endif

bool ScoreParserXML::parseWav(xmlNodePtr node)
{
    double x = -1.0, y = 0.0, z = 0.0;
    double startTime = -1.0, gain = 1.0;
    int interpolated = -1, negated = -1;

    // allow interpolation and negation to be configured from XML
    BOOL_ATTRIBUTE("wav input", "interpolated", interpolated);
    BOOL_ATTRIBUTE("wav input", "negated", negated);

    BEGIN_PROPERTIES("wav input");
    STRING_PROPERTY("component", component);
    STRING_PROPERTY("filename", filename);
    DOUBLE_PROPERTY("x", x);
    DOUBLE_PROPERTY("y", y);
    DOUBLE_PROPERTY("z", z);
    DOUBLE_PROPERTY("startTime", startTime);
    DOUBLE_PROPERTY("gain", gain);
    END_PROPERTIES;

    // check we got everything we need
    if ((!component) || (!filename) || (x < 0.0) || (startTime < 0.0)) {
	logMessage(5, "Wav input definition is missing required value");
	if (component) free(component);
	if (filename) free(filename);
	return false;
    }

    // find the component
    Component *comp = instrument->getComponentByName(component);
    if (!comp) {
	logMessage(5, "Unrecognised component name %s in wav input definition",
		   component);
	free(component);
	if (filename) free(filename);
	return false;
    }
    free(component);

    // actually create the input
    comp->addInput(new InputWav(comp, x, y, z, filename, startTime, gain,
				interpolated, negated));
    free(filename);

    return true;
}

#ifndef GUITAR_ONLY

bool ScoreParserXML::parseLips(xmlNodePtr node)
{
    vector<double> Sr, mu, sigma, H, w, pressure, lip_frequency, vibamp, vibfreq, tremamp, tremfreq, noiseamp;

    BEGIN_PROPERTIES("lips");
    STRING_PROPERTY("component", component);
    BREAKPOINT_PROPERTY("effectiveSurfaceArea", Sr, "time", "area");
    BREAKPOINT_PROPERTY("effectiveMass", mu, "time", "mass");
    BREAKPOINT_PROPERTY("damping", sigma, "time", "damping");
    BREAKPOINT_PROPERTY("equilibriumSeparation", H, "time", "separation");
    BREAKPOINT_PROPERTY("width", w, "time", "width");
    BREAKPOINT_PROPERTY("mouthPressure", pressure, "time", "pressure");
    BREAKPOINT_PROPERTY("lipFrequency", lip_frequency, "time", "frequency");
    BREAKPOINT_PROPERTY("vibratoAmplitude", vibamp, "time", "amplitude");
    BREAKPOINT_PROPERTY("vibratoFrequency", vibfreq, "time", "frequency");
    BREAKPOINT_PROPERTY("tremoloAmplitude", tremamp, "time", "amplitude");
    BREAKPOINT_PROPERTY("tremoloFrequency", tremfreq, "time", "frequency");
    BREAKPOINT_PROPERTY("noiseAmplitude", noiseamp, "time", "amplitude");
    END_PROPERTIES;

    // check we got everything we need
    if (!component) {
	logMessage(5, "Lips definition is missing required value");
	if (component) free(component);
	return false;
    }

    // find component
    Component *comp = instrument->getComponentByName(component);
    if (!comp) {
	logMessage(5, "Unrecognised component name %s in lips definition", component);
	free(component);
	return false;
    }
    free(component);

    // make sure it is a BrassInstrument
    BrassInstrument *brass = dynamic_cast<BrassInstrument*>(comp);
    if (!brass) {
	logMessage(5, "Lip inputs can only be used with brass components");
	return false;
    }

    brass->addInput(new InputLips(brass, Sr, mu, sigma, H, w, pressure, lip_frequency, vibamp,
				  vibfreq, tremamp, tremfreq, noiseamp));
    return true;
}

bool ScoreParserXML::parseValve(xmlNodePtr node)
{
    static int valveIndex = 0;
    vector<double> opening, vibratoFrequency, vibratoAmplitude;
    
    BEGIN_PROPERTIES("valve");
    STRING_PROPERTY("component", component);
    BREAKPOINT_PROPERTY("opening", opening, "time", "amount");
    BREAKPOINT_PROPERTY("vibratoAmplitude", vibratoAmplitude, "time", "amplitude");
    BREAKPOINT_PROPERTY("vibratoFrequency", vibratoFrequency, "time", "frequency");
    END_PROPERTIES;

    // check we got everything we need
    if (!component) {
	logMessage(5, "Valve definition is missing required value");
	if (component) free(component);
	return false;
    }

    // find component
    Component *comp = instrument->getComponentByName(component);
    if (!comp) {
	logMessage(5, "Unrecognised component name %s in valve definition", component);
	free(component);
	return false;
    }
    free(component);

    // make sure it is a BrassInstrument
    BrassInstrument *brass = dynamic_cast<BrassInstrument*>(comp);
    if (!brass) {
	logMessage(5, "Valve inputs can only be used with brass components");
	return false;
    }

    brass->addInput(new InputValve(brass, valveIndex, opening, vibratoFrequency,
				   vibratoAmplitude));
    valveIndex++;

    return true;
}

#endif


bool ScoreParserXML::parseDouble(xmlNodePtr node, double *result)
{
    double dbl;
    char *val = (char *)xmlNodeListGetString(doc, node->xmlChildrenNode, 1);
    stringstream ss(val, stringstream::in);
    ss >> dbl;
    xmlFree(val);
    if (ss.bad()) {
	return false;
    }
    *result = dbl;
    return true;
}

bool ScoreParserXML::parseInt(xmlNodePtr node, int *result)
{
    int i;
    char *val = (char *)xmlNodeListGetString(doc, node->xmlChildrenNode, 1);
    stringstream ss(val, stringstream::in);
    ss >> i;
    xmlFree(val);
    if (ss.bad()) {
	return false;
    }
    *result = i;
    return true;
}

// caller must free the returned string
char *ScoreParserXML::parseString(xmlNodePtr node)
{
    char *val = (char *)xmlNodeListGetString(doc, node->xmlChildrenNode, 1);
    int startidx, endidx;
    char *result;

    startidx = 0;
    endidx = strlen(val) - 1;

    // skip leading space
    while ((val[startidx]) && (isspace(val[startidx]))) startidx++;
    // skip trailing space
    while ((endidx > startidx) && (isspace(val[endidx]))) endidx--;
    if (endidx < startidx) endidx = startidx;

    int len = (endidx - startidx) + 1;
    result = (char *)malloc(len+1);
    strncpy(result, &val[startidx], len);
    result[len] = 0;

    xmlFree(val);
    return result;
}

bool ScoreParserXML::parseBreakpointFunction(xmlNodePtr node, const char *tag1, const char *tag2, vector<double> *result)
{
    double val1 = -1.0, val2 = -1.0;
    xmlNodePtr child = node->xmlChildrenNode;

    while (child) {
	if (!xmlStrcmp(child->name, (const xmlChar *)tag1)) {
	    if (!parseDouble(child, &val1)) {
		logMessage(5, "Invalid %s value in breakpoint definition", tag1);
		return false;
	    }
	    if (val2 >= 0.0) {
		logMessage(5, "Expected %s-%s pairs in breakpoint definition", tag1, tag2);
		return false;
	    }
	}
	else if (!xmlStrcmp(child->name, (const xmlChar *)tag2)) {
	    if (!parseDouble(child, &val2)) {
		logMessage(5, "Invalid %s value in breakpoint definition", tag2);
		return false;
	    }
	    if (val1 < 0.0) {
		logMessage(5, "Expected %s-%s pairs in breakpoint definition", tag1, tag2);
		return false;
	    }
	    result->push_back(val1);
	    result->push_back(val2);
	    val1 = -1.0;
	    val2 = -1.0;
	}
	else if (xmlStrcmp(child->name, (const xmlChar *)"text")) {
	    logMessage(1, "Unrecognised element %s in breakpoint definition", child->name);
	}

	child = child->next;
    }
    return true;
}

