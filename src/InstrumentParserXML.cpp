/*
 * NeSS Framework Code
 *
 * Copyright (c) The University of Edinburgh, 2014-2016. All rights reserved.
 *
 * Author: James Perry (j.perry@epcc.ed.ac.uk)
 */

#include "InstrumentParserXML.h"
#include "Logger.h"
#include "SettingsManager.h"
#include "GlobalSettings.h"
#include "Output.h"
#include "OutputDifference.h"
#include "OutputPressure.h"
#include "MaterialsManager.h"

#ifndef GUITAR_ONLY
#include "BrassInstrument.h"
#endif

#ifndef BRASS_ONLY
#ifndef GUITAR_ONLY
#include "AirboxIndexed.h"
#include "Plate.h"
#include "ConnectionZero.h"
#include "ConnectionZeroPt1.h"
#include "PlateEmbedded.h"
#include "Embedding.h"
#include "ComponentString.h"
#include "SoundBoard.h"
#include "StringWithFrets.h"
#include "Bar.h"
#include "Fretboard.h"
#include "BowedString.h"
#include "ModalPlate.h"
#include "OutputModal.h"
#endif
#endif

#include <cstdlib>
#include <cctype>
#include <cstring>
#include <iostream>
#include <sstream>
#include <vector>
using namespace std;

InstrumentParserXML::InstrumentParserXML(string filename) : InstrumentParser(filename)
{
}

InstrumentParserXML::~InstrumentParserXML()
{
}

static void errorHandler(void *ctx, const char *msg, ...)
{
    logMessage(3, "Instrument file is not valid XML");
}

static void structuredErrorHandler(void *ctx, const xmlError *data)
{
    logMessage(3, "Instrument file is not valid XML");
}

Instrument *InstrumentParserXML::parse()
{
    xmlNodePtr node;
    bool success = true;

    // suppress the error messages generated by libxml2 and use our own instead
    xmlSetGenericErrorFunc(NULL, errorHandler);
    xmlSetStructuredErrorFunc(NULL, (xmlStructuredErrorFunc)structuredErrorHandler);

    // parse the file into a document object
    doc = xmlParseFile(filename.c_str());
    if (doc == NULL) {
	logMessage(1, "Failed to parse instrument file as XML");
	return NULL;
    }

    // check for correct root element
    node = xmlDocGetRootElement(doc);
    if (node == NULL) {
	logMessage(1, "XML document is empty");
	xmlFreeDoc(doc);
	return NULL;
    }

    if (xmlStrcmp(node->name, (const xmlChar *)"instrument")) {
	logMessage(1, "Expected instrument node at root of XML file");
	xmlFreeDoc(doc);
	return NULL;
    }

    instrument = new Instrument();

    // now loop over children of the root element
    node = node->xmlChildrenNode;
    while ((node != NULL) && (success)) {
	if (!xmlStrcmp(node->name, (const xmlChar *)"output")) {
	    if (!parseOutput(node)) {
		success = false;
	    }
	}
#ifndef GUITAR_ONLY
	else if (!xmlStrcmp(node->name, (const xmlChar *)"brass")) {
	    if (!parseBrass(node)) {
		success = false;
	    }
	}
#endif
	else if (!xmlStrcmp(node->name, (const xmlChar *)"samplerate")) {
	    double sr;
	    if (!parseDouble(node, &sr)) {
		logMessage(5, "Invalid sample rate in instrument file");
		success = false;
	    }
	    else {
		logMessage(1, "Setting sample rate to %f", sr);
		GlobalSettings::getInstance()->setSampleRate(sr);
	    }
	}
	else if ((!xmlStrcmp(node->name, (const xmlChar *)"normaliseOuts")) ||
		 (!xmlStrcmp(node->name, (const xmlChar *)"normalizeOuts"))) {
	    bool no;
	    if (!parseBoolean(node, &no)) {
		logMessage(5, "Invalid normalise outs value in instrument file");
		success = false;
	    }
	    else {
		logMessage(1, "Setting normalise outs to %d", (int)no);
		GlobalSettings::getInstance()->setNormaliseOuts(no);
	    }
	}
#ifndef BRASS_ONLY
	else if (!xmlStrcmp(node->name, (const xmlChar *)"guitarString")) {
	    if (!parseGuitarString(node, NULL)) {
		success = false;
	    }
	}
	else if (!xmlStrcmp(node->name, (const xmlChar *)"guitar")) {
	    if (!parseGuitar(node)) {
		success = false;
	    }
	}
#ifndef GUITAR_ONLY
	else if (!xmlStrcmp(node->name, (const xmlChar *)"connection")) {
	    if (!parseConnection(node)) {
		success = false;
	    }
	}
	else if (!xmlStrcmp(node->name, (const xmlChar *)"airbox")) {
	    // parse airbox node
	    if (!parseAirbox(node)) {
		success = false;
	    }
	}
	else if (!xmlStrcmp(node->name, (const xmlChar *)"plate")) {
	    if (!parsePlate(node)) {
		success = false;
	    }
	}
	else if (!xmlStrcmp(node->name, (const xmlChar *)"membrane")) {
	    if (!parsePlateEmbedded(node, NULL, true)) {
		success = false;
	    }
	}
	else if (!xmlStrcmp(node->name, (const xmlChar *)"bar")) {
	    if (!parseBar(node)) {
		success = false;
	    }
	}
	else if (!xmlStrcmp(node->name, (const xmlChar *)"string")) {
	    if (!parseComponentString(node, NULL)) {
		success = false;
	    }
	}
	else if (!xmlStrcmp(node->name, (const xmlChar *)"fretboard")) {
	    if (!parseFretboard(node)) {
		success = false;
	    }
	}
	else if (!xmlStrcmp(node->name, (const xmlChar *)"bowedString")) {
	    if (!parseBowedString(node, NULL)) {
		success = false;
	    }
	}
	else if (!xmlStrcmp(node->name, (const xmlChar *)"modalPlate")) {
	    if (!parseModalPlate(node)) {
		success = false;
	    }
	}
#endif
#endif
	else if (xmlStrcmp(node->name, (const xmlChar *)"text")) {
	    // allow unknown elements for future extensibility
	    logMessage(1, "Unrecognised element %s in XML instrument file",
		       node->name);
	}

	node = node->next;
    }

    xmlFreeDoc(doc);

    if (!success) {
	delete instrument;
	instrument = NULL;
    }

    return instrument;
}

bool InstrumentParserXML::parseBoolean(xmlNodePtr node, bool *result)
{
    // use parseString to make sure white space is stripped
    char *val = parseString(node);
    bool success = false;

    if ((!strcmp(val, "0")) || (!strcmp(val, "false")) ||
	(!strcmp(val, "False")) || (!strcmp(val, "FALSE"))) {
	*result = false;
	success = true;
    }
    else if ((!strcmp(val, "1")) || (!strcmp(val, "true")) ||
	     (!strcmp(val, "True")) || (!strcmp(val, "TRUE"))) {
	*result = true;
	success = true;
    }
    free(val);
    return success;
}

bool InstrumentParserXML::parseDouble(xmlNodePtr node, double *result)
{
    double dbl;
    char *val = (char *)xmlNodeListGetString(doc, node->xmlChildrenNode, 1);
    stringstream ss(val, stringstream::in);
    ss >> dbl;
    xmlFree(val);
    if (ss.bad()) {
	return false;
    }
    *result = dbl;
    return true;
}

bool InstrumentParserXML::parseInt(xmlNodePtr node, int *result)
{
    int i;
    char *val = (char *)xmlNodeListGetString(doc, node->xmlChildrenNode, 1);
    stringstream ss(val, stringstream::in);
    ss >> i;
    xmlFree(val);
    if (ss.bad()) {
	return false;
    }
    *result = i;
    return true;
}

// caller must free the returned string
char *InstrumentParserXML::parseString(xmlNodePtr node)
{
    char *val = (char *)xmlNodeListGetString(doc, node->xmlChildrenNode, 1);
    int startidx, endidx;
    char *result;

    startidx = 0;
    endidx = strlen(val) - 1;

    // skip leading space
    while ((val[startidx]) && (isspace(val[startidx]))) startidx++;
    // skip trailing space
    while ((endidx > startidx) && (isspace(val[endidx]))) endidx--;
    if (endidx < startidx) endidx = startidx;

    int len = (endidx - startidx) + 1;
    result = (char *)malloc(len+1);
    strncpy(result, &val[startidx], len);
    result[len] = 0;

    xmlFree(val);
    return result;
}

/*
 * macros to streamline the component parsers
 */
// extract name attribute from xmlNodePtr node, into string name
#define NAME_ATTRIBUTE(tname) \
    xmlChar *xname = xmlGetProp(node, (const xmlChar *)"name"); \
    if (!xname) { \
        logMessage(5, "%s definition is missing name attribute", tname); \
	return false; \
    } \
    string name = (const char *)xname; \
    xmlFree(xname); \


// begin property processing loop for children of xmlNodePtr node
#define BEGIN_PROPERTIES(tname) \
    char *component1 = NULL; \
    char *component2 = NULL; \
    char *matname = NULL; \
    bool recognised = false; \
    xmlNodePtr child = node->xmlChildrenNode; \
    const char *tpname = tname; \
    while (child != NULL) { \


// end propery processing loop
#define END_PROPERTIES \
        if (!recognised) { \
	    if (xmlStrcmp(child->name, (const xmlChar *)"text")) { \
	        logMessage(1, "Unrecognised element %s in %s definition", \
			   child->name, tpname); \
            } \
	} \
        child = child->next; \
    } \


#define DOUBLE_PROPERTY(propname, var) \
    if (!xmlStrcmp(child->name, (const xmlChar *)propname)) { \
        if (!parseDouble(child, &var)) { \
	    logMessage(5, "Invalid %s value in %s definition", propname, tpname); \
	    if (matname) free(matname); \
	    if (component1) free(component1); \
	    if (component2) free(component2); \
	    return false; \
	} \
	recognised = true; \
    } \


#define INT_PROPERTY(propname, var) \
    if (!xmlStrcmp(child->name, (const xmlChar *)propname)) { \
        if (!parseInt(child, &var)) { \
	    logMessage(5, "Invalid %s value in %s definition", propname, tpname); \
	    if (matname) free(matname); \
	    if (component1) free(component1); \
	    if (component2) free(component2); \
	    return false; \
	} \
	recognised = true; \
    } \


#define STRING_PROPERTY(propname, var) \
    if (!xmlStrcmp(child->name, (const xmlChar *)propname)) { \
        var = parseString(child); \
	recognised = true; \
    } \


#define BOOL_PROPERTY(propname, var) \
    if (!xmlStrcmp(child->name, (const xmlChar *)propname)) { \
        char *tmpstr; \
        tmpstr = parseString(child); \
	if (!strcmp(tmpstr, "true")) { \
	    var = true; \
	} \
	else if (!strcmp(tmpstr, "false")) { \
	    var = false; \
	} \
	else { \
	    free(tmpstr); \
	    logMessage(5, "Invalid %s value in %s definition", propname, tpname); \
	    if (matname) free(matname); \
	    if (component1) free(component1); \
	    if (component2) free(component2); \
	    return false; \
	} \
	free(tmpstr); \
	recognised = true; \
    } \


#define DOUBLE_SETTING(propname, settingname) \
    if (!xmlStrcmp(child->name, (const xmlChar *)propname)) { \
        double var; \
	if (!parseDouble(child, &var)) { \
	    logMessage(5, "Invalid %s value in %s definition", propname, tpname); \
	    if (matname) free(matname); \
	    if (component1) free(component1); \
	    if (component2) free(component2); \
	    return false; \
	} \
	recognised = true; \
	SettingsManager::getInstance()->putSetting(name, settingname, var); \
    } \


#define INT_SETTING(propname, settingname) \
    if (!xmlStrcmp(child->name, (const xmlChar *)propname)) { \
        int var; \
	if (!parseInt(child, &var)) { \
	    logMessage(5, "Invalid %s value in %s definition", propname, tpname); \
	    if (matname) free(matname); \
	    if (component1) free(component1); \
	    if (component2) free(component2); \
	    return false; \
	} \
	recognised = true; \
	SettingsManager::getInstance()->putSettingInt(name, settingname, var); \
    } \


#define STRING_SETTING(propname, settingname) \
    if (!xmlStrcmp(child->name, (const xmlChar *)propname)) { \
        char *var; \
	var = parseString(child); \
        recognised = true; \
	SettingsManager::getInstance()->putSetting(name, settingname, var); \
        free(var); \
    } \


#define BOOL_SETTING(propname, settingname) \
    if (!xmlStrcmp(child->name, (const xmlChar *)propname)) { \
        char *var; \
	var = parseString(child); \
        if (!strcmp(var, "true")) { \
	    recognised = true; \
	    SettingsManager::getInstance()->putSettingBool(name, settingname, true); \
	} \
	else if (!strcmp(var, "false")) { \
	    recognised = true; \
	    SettingsManager::getInstance()->putSettingBool(name, settingname, false); \
	} \
        else { \
	    free(var); \
	    logMessage(5, "Invalid %s value in %s definition", propname, tpname); \
	    if (matname) free(matname); \
	    if (component1) free(component1); \
	    if (component2) free(component2); \
	    return false; \
	} \
        free(var); \
    } \

#ifndef GUITAR_ONLY

bool InstrumentParserXML::parseBrass(xmlNodePtr node)
{
    double temperature = -1.0;
    vector<double> vpos, vdl, vbl;
    vector<double> borev;

    double xmeg = -1.0, Leg = -1.0, rmeg = -1.0, rbeg = -1.0, fbeg = -1.0;
    vector<double> x0eg, r0eg;

    // get name attribute, which must be present
    NAME_ATTRIBUTE("brass");
    BEGIN_PROPERTIES("brass");
    DOUBLE_PROPERTY("temperature", temperature);
    DOUBLE_PROPERTY("xmeg", xmeg);
    DOUBLE_PROPERTY("Leg", Leg);
    DOUBLE_PROPERTY("rmeg", rmeg);
    DOUBLE_PROPERTY("rbeg", rbeg);
    DOUBLE_PROPERTY("fbeg", fbeg);
    if (!xmlStrcmp(child->name, (const xmlChar *)"x0eg")) {
	double length = -1.0;
	recognised = true;
	xmlNodePtr x0node = child->xmlChildrenNode;
	while (x0node != NULL) {
	    if (!xmlStrcmp(x0node->name, (const xmlChar *)"length")) {
		if (!parseDouble(x0node, &length)) {
		    logMessage(5, "Invalid middle length value");
		    return false;
		}
		x0eg.push_back(length);
	    }
	    else if (xmlStrcmp(x0node->name, (const xmlChar *)"text")) {
		logMessage(1, "Unrecognised element %s in middle lengths definition", x0node->name);
	    }
	    x0node = x0node->next;
	}
    }
    if (!xmlStrcmp(child->name, (const xmlChar *)"r0eg")) {
	double value1 = -1.0, value2 = -1.0, type = -1.0;
	recognised = true;
	xmlNodePtr r0node = child->xmlChildrenNode;
	while (r0node != NULL) {
	    if (!xmlStrcmp(r0node->name, (const xmlChar *)"value1")) {
		if (!parseDouble(r0node, &value1)) {
		    logMessage(5, "Invalid value in middle bore parameters");
		    return false;
		}
	    }
	    else if (!xmlStrcmp(r0node->name, (const xmlChar *)"value2")) {
		if (!parseDouble(r0node, &value2)) {
		    logMessage(5, "Invalid value in middle bore parameters");
		    return false;
		}
	    }
	    else if (!xmlStrcmp(r0node->name, (const xmlChar *)"type")) {
		char *tstr = parseString(r0node);
		if (!strcmp(tstr, "single")) {
		    type = 1;
		    value1 = value2;
		}
		else if (!strcmp(tstr, "squaredsine")) {
		    type = 2;
		}
		else if (!strcmp(tstr, "cosine")) {
		    type = 3;
		}
		else {
		    free(tstr);
		    logMessage(5, "Invalid type in middle bore parameters (must be single, squaredsine or cosine)");
		    return false;
		}
		free(tstr);

		// add a row to r0eg now
		if ((value1 < 0.0) || (value2 < 0.0)) {
		    logMessage(5, "Missing value in middle bore parameters");
		    return false;
		}
		r0eg.push_back(value1);
		r0eg.push_back(value2);
		r0eg.push_back(type);
		value1 = -1.0;
		value2 = -1.0;
		type = -1.0;
	    }
	    else if (xmlStrcmp(r0node->name, (const xmlChar *)"text")) {
		logMessage(1, "Unrecognised element %s in middle bore parameters", r0node->name);
	    }
	    r0node = r0node->next;
	}
    }
    if (!xmlStrcmp(child->name, (const xmlChar *)"valve")) {
	double pos = -1.0, dl = -1.0, bl = -1.0;

	recognised = true;
	xmlNodePtr valve = child->xmlChildrenNode;
	while (valve != NULL) {
	    if (!xmlStrcmp(valve->name, (const xmlChar *)"position")) {
		if (!parseDouble(valve, &pos)) {
		    logMessage(5, "Invalid valve position value");
		    return false;
		}
	    }
	    else if (!xmlStrcmp(valve->name, (const xmlChar *)"defaultLength")) {
		if (!parseDouble(valve, &dl)) {
		    logMessage(5, "Invalid valve default length value");
		    return false;
		}
	    }
	    else if (!xmlStrcmp(valve->name, (const xmlChar *)"bypassLength")) {
		if (!parseDouble(valve, &bl)) {
		    logMessage(5, "Invalid valve bypass length value");
		    return false;
		}
	    }
	    else if (xmlStrcmp(valve->name, (const xmlChar *)"text")) {
		logMessage(1, "Unrecognised element %s in valve definition",
			   valve->name);
	    }
	    valve = valve->next;
	}
	if ((pos < 0.0) || (dl < 0.0) || (bl < 0.0)) {
	    logMessage(5, "Valve definition is missing a required value");
	    return false;
	}
	vpos.push_back(pos);
	vdl.push_back(dl);
	vbl.push_back(bl);
    }
    if (!xmlStrcmp(child->name, (const xmlChar *)"bore")) {
	recognised = true;
	xmlNodePtr bore = child->xmlChildrenNode;
	double x = -1.0, diameter = -1.0;

	while (bore != NULL) {
	    if (!xmlStrcmp(bore->name, (const xmlChar *)"x")) {
		if (!parseDouble(bore, &x)) {
		    logMessage(5, "Invalid x value in bore definition");
		    return false;
		}
		if (diameter >= 0.0) {
		    logMessage(5, "Expected x and diameter pairs in bore definition");
		    return false;
		}
	    }
	    else if (!xmlStrcmp(bore->name, (const xmlChar *)"diameter")) {
		if (!parseDouble(bore, &diameter)) {
		    logMessage(5, "Invalid diameter value in bore definition");
		    return false;
		}
		if (x < 0.0) {
		    logMessage(5, "Expected x and diameter pairs in bore definition");
		    return false;
		}
		borev.push_back(x);
		borev.push_back(diameter);
		x = -1.0;
		diameter = -1.0;
	    }
	    else if (xmlStrcmp(bore->name, (const xmlChar *)"text")) {
		logMessage(1, "Unrecognised element %s in bore definition",
			   bore->name);
	    }
	    bore = bore->next;
	}
    }
    END_PROPERTIES;

    if (temperature < 0.0) {
	logMessage(5, "Brass definition is missing a required value");
	return false;
    }

    BrassInstrument *brass;
    if (borev.size() > 0) {
	// normal
	brass = new BrassInstrument(name, temperature, vpos.size(), vpos,
				    vdl, vbl, borev);
    }
    else {
	// custom instrument
	if ((xmeg < 0.0) || (Leg < 0.0) || (rmeg < 0.0) || (rbeg < 0.0) || (fbeg < 0.0)) {
	    logMessage(5, "Brass definition is missing a required value");
	    return false;
	}
	brass = new BrassInstrument(name, temperature, vpos.size(), vpos,
				    vdl, vbl, xmeg, x0eg, Leg, rmeg, r0eg, rbeg, fbeg);
    }
    instrument->addComponent(brass);

    return true;
}

#endif

#ifndef BRASS_ONLY

bool InstrumentParserXML::parseGuitar(xmlNodePtr node)
{
    vector<GuitarString*> strings;
    double b0 = -0.002, b1 = -0.001, b2 = -0.0002;
    vector<double> fretpos, fretheight;
    double Kb = 1e10, alphab = 1.3, betab = 10.0;
    double Mf = 0.005, Kf = 1e7, alphaf = 3.3, betaf = 100.0;
    GuitarString *str;
    int i;
    bool collisions = false;

    // parse the elements
    xmlNodePtr child = node->xmlChildrenNode;
    while (child != NULL) {
	if ((!xmlStrcmp(child->name, (const xmlChar *)"string")) ||
	    (!xmlStrcmp(child->name, (const xmlChar *)"guitarString"))) {
	    // found a string
	    if (!parseGuitarString(child, &str)) {
		return false;
	    }
	    strings.push_back(str);
	}
	else if (!xmlStrcmp(child->name, (const xmlChar *)"connection")) {
	    // found a net1 connection
	    if (!parseConnectionNet1(child)) {
		return false;
	    }
	}
	else if (!xmlStrcmp(child->name, (const xmlChar *)"backboard")) {
	    collisions = true;
	    xmlNodePtr barr = child->xmlChildrenNode;
	    while (barr != NULL) {
		if (!xmlStrcmp(barr->name, (const xmlChar *)"b0")) {
		    if (!parseDouble(barr, &b0)) {
			logMessage(5, "Invalid backboard b0");
			return false;
		    }
		}
		else if (!xmlStrcmp(barr->name, (const xmlChar *)"b1")) {
		    if (!parseDouble(barr, &b1)) {
			logMessage(5, "Invalid backboard b1");
			return false;
		    }
		}
		else if (!xmlStrcmp(barr->name, (const xmlChar *)"b2")) {
		    if (!parseDouble(barr, &b2)) {
			logMessage(5, "Invalid backboard b2");
			return false;
		    }
		}
		else if (xmlStrcmp(barr->name, (const xmlChar *)"text")) {
		    logMessage(1, "Unrecognised element %s in backboard definition", barr->name);
		}

		barr = barr->next;
	    }
	}
	else if (!xmlStrcmp(child->name, (const xmlChar *)"finger")) {
	    collisions = true;
	    xmlNodePtr fing = child->xmlChildrenNode;
	    while (fing != NULL) {
		if (!xmlStrcmp(fing->name, (const xmlChar *)"Mf")) {
		    if (!parseDouble(fing, &Mf)) {
			logMessage(5, "Invalid Mf value in guitar finger");
			return false;
		    }
		}
		else if (!xmlStrcmp(fing->name, (const xmlChar *)"Kf")) {
		    if (!parseDouble(fing, &Kf)) {
			logMessage(5, "Invalid Kf value in guitar finger");
			return false;
		    }
		}
		else if (!xmlStrcmp(fing->name, (const xmlChar *)"alphaf")) {
		    if (!parseDouble(fing, &alphaf)) {
			logMessage(5, "Invalid alphaf value in guitar finger");
			return false;
		    }
		}
		else if (!xmlStrcmp(fing->name, (const xmlChar *)"betaf")) {
		    if (!parseDouble(fing, &betaf)) {
			logMessage(5, "Invalid betaf value in guitar finger");
			return false;
		    }
		}
		else if (xmlStrcmp(fing->name, (const xmlChar *)"text")) {
		    logMessage(1, "Unrecognised element %s in guitar finger definition", fing->name);
		}

		fing = fing->next;
	    }
	}
	else if (!xmlStrcmp(child->name, (const xmlChar *)"fret")) {
	    collisions = true;
	    xmlNodePtr fretnode = child->xmlChildrenNode;
	    double fh = 1.0, fp = -1.0;
	    while (fretnode != NULL) {
		if (!xmlStrcmp(fretnode->name, (const xmlChar *)"pos")) {
		    if (!parseDouble(fretnode, &fp)) {
			logMessage(5, "Invalid fret position");
			return false;
		    }
		}
		else if (!xmlStrcmp(fretnode->name, (const xmlChar *)"height")) {
		    if (!parseDouble(fretnode, &fh)) {
			logMessage(5, "Invalid fret height");
			return false;
		    }
		}
		else if (xmlStrcmp(fretnode->name, (const xmlChar *)"text")) {
		    logMessage(1, "Unrecognised element %s in fret definition", fretnode->name);
		}
		fretnode = fretnode->next;
	    }

	    if ((fh > 0.0) || (fp < 0.0)) {
		logMessage(5, "Fret definition is missing required value");
		return false;
	    }
	    fretpos.push_back(fp);
	    fretheight.push_back(fh);
	}
	else if (!xmlStrcmp(child->name, (const xmlChar *)"Kb")) {
	    collisions = true;
	    if (!parseDouble(child, &Kb)) {
		logMessage(5, "Invalid Kb value");
		return false;
	    }
	}
	else if (!xmlStrcmp(child->name, (const xmlChar *)"alphab")) {
	    collisions = true;
	    if (!parseDouble(child, &alphab)) {
		logMessage(5, "Invalid alphab value");
		return false;
	    }
	}
	else if (!xmlStrcmp(child->name, (const xmlChar *)"betab")) {
	    collisions = true;
	    if (!parseDouble(child, &betab)) {
		logMessage(5, "Invalid betab value");
		return false;
	    }
	}
	else if (xmlStrcmp(child->name, (const xmlChar *)"text")) {
	    logMessage(1, "Unrecognised element %s in guitar definition", child->name);
	}

	child = child->next;
    }


    // set up all the strings properly
    if (collisions) {
	for (i = 0; i < strings.size(); i++) {
	    str = strings[i];
	    str->setBackboard(b0, b1, b2);
	    str->setFrets(fretpos, fretheight);
	    str->setBarrierParams(Kb, alphab, betab);
	    str->setFingerParams(Mf, Kf, alphaf, betaf);
	}
    }

    return true;
}

bool InstrumentParserXML::parseGuitarString(xmlNodePtr node, GuitarString **result)
{
    double L = -1.0, E = -1.0, T = -1.0, r = -1.0, rho = -1.0;
    double T60_0 = -1.0, T60_1000 = -1.0;

    // get name attribute, which must be present
    NAME_ATTRIBUTE("guitarString");

    // parse the required properties
    BEGIN_PROPERTIES("guitarString");
    DOUBLE_PROPERTY("length", L);
    DOUBLE_PROPERTY("youngsModulus", E);
    DOUBLE_PROPERTY("tension", T);
    DOUBLE_PROPERTY("radius", r);
    DOUBLE_PROPERTY("density", rho);
    DOUBLE_PROPERTY("T60_0", T60_0);
    DOUBLE_PROPERTY("T60_1000", T60_1000);
    END_PROPERTIES;

    // check we have everything needed
    if ((L < 0.0) || (E < 0.0) || (T < 0.0) || (r < 0.0) || (rho < 0.0) ||
	(T60_0 < 0.0) || (T60_1000 < 0.0)) {
	logMessage(5, "Guitar string definition is missing required value");
	return false;
    }

    // instantiate the string
    GuitarString *gs = new GuitarString(name, L, E, T, r, rho, T60_0, T60_1000);
    instrument->addComponent(gs);
    if (result) {
	*result = gs;
    }
    return true;
}

bool InstrumentParserXML::parseConnectionNet1(xmlNodePtr node)
{
    double x1 = -1.0, x2 = -1.0;
    double mass = -1.0, frequency = -1.0, loss = -1.0;
    double collisionExponent = -1.0, rattlingDistance = -1.0;
    int i;

    BEGIN_PROPERTIES("connection");
    if (!xmlStrcmp(child->name, (const xmlChar *)"component")) {
	recognised = true;
	if (!component1) {
	    component1 = parseString(child);
	}
	else if (!component2) {
	    component2 = parseString(child);
	}
	else {
	    free(component1);
	    free(component2);
	    logMessage(5, "More than two components in a connection definition");
	    return false;
	}
    }
    DOUBLE_PROPERTY("x1", x1);
    DOUBLE_PROPERTY("x2", x2);
    DOUBLE_PROPERTY("mass", mass);
    DOUBLE_PROPERTY("frequency", frequency);
    DOUBLE_PROPERTY("loss", loss);
    DOUBLE_PROPERTY("collisionExponent", collisionExponent);
    DOUBLE_PROPERTY("rattlingDistance", rattlingDistance);
    END_PROPERTIES;

    // check for basics
    if ((!component1) || (x1 < 0.0) || (mass < 0.0) || (frequency < 0.0) ||
	(loss < 0.0) || (collisionExponent < 0.0) || (rattlingDistance < 0.0)) {
	logMessage(5, "Connection definition is missing a required value");
	return false;
    }

    // find the component(s)
    Component *c1 = instrument->getComponentByName(component1);
    Component *c2 = NULL;
    if (!c1) {
	logMessage(5, "Unrecognised component name %s in connection definition",
		   component1);
	free(component1);
	if (component2) free(component2);
	return false;
    }
    if (component2) {
	c2 = instrument->getComponentByName(component2);
	if (!c2) {
	    logMessage(5, "Unrecognised component name %s in connection definition",
		       component2);
	    free(component1);
	    free(component2);
	    return false;
	}
    }
    free(component1);
    if (component2) free(component2);

    // create the connection
    ConnectionNet1 *conn = new ConnectionNet1(c1, c2, mass, frequency, loss,
					      collisionExponent, rattlingDistance,
					      x1, x2);

    // reject co-incident connections
    for (i = 0; i < net1Connections.size(); i++) {
	if (net1Connections[i]->coincides(conn)) {
	    logMessage(1, "Removing co-incident connection");
	    delete conn;
	    return true;
	}
    }

    // add to instrument
    instrument->addConnection(conn);
    net1Connections.push_back(conn);

    return true;
}

#ifndef GUITAR_ONLY

bool InstrumentParserXML::parseModalPlate(xmlNodePtr node)
{
    double nu = -1.0, rho = -1.0, E = -1.0, h = -1.0;
    double lx = -1.0, ly = -1.0;
    double loss1 = -1.0, loss2 = -1.0;
    bool halfNyquist = false;
    int A = -1;
    int type = -1;

    // get name attribute, which must be present
    NAME_ATTRIBUTE("modalPlate");

    BEGIN_PROPERTIES("modalPlate");
    DOUBLE_PROPERTY("poissonsRatio", nu);
    DOUBLE_PROPERTY("density", rho);
    DOUBLE_PROPERTY("youngsModulus", E);
    DOUBLE_PROPERTY("h", h);
    DOUBLE_PROPERTY("lx", lx);
    DOUBLE_PROPERTY("ly", ly);
    DOUBLE_PROPERTY("loss1", loss1);
    DOUBLE_PROPERTY("loss2", loss2);
    INT_PROPERTY("A", A);
    INT_PROPERTY("type", type);
    END_PROPERTIES;

    // handle pre-defined plate types
    if (type >= 0) {
	double fs = 20000.0;
	switch (type) {
	case 1:
	    A = 9;
	    lx = 0.22;
	    ly = 0.21;
	    h = 0.0005;
	    nu = 0.3;
	    E = 2e11;
	    rho = 7860.0;
	    fs = 20000.0;
	    if (loss1 < 0.0) loss1 = 1.0;
	    if (loss2 < 0.0) loss2 = 0.1;
	    break;
	case 2:
	    A = 9;
	    lx = 0.32;
	    ly = 0.31;
	    h = 0.001;
	    nu = 0.3;
	    E = 2e11;
	    rho = 7860.0;
	    fs = 20000.0;
	    if (loss1 < 0.0) loss1 = 1.0;
	    if (loss2 < 0.0) loss2 = 0.1;
	    break;
	case 3:
	    A = 9;
	    lx = 0.2;
	    ly = 0.2;
	    h = 0.0002;
	    nu = 0.3;
	    E = 2e11;
	    rho = 7860.0;
	    fs = 40000.0;
	    halfNyquist = true;
	    if (loss1 < 0.0) loss1 = 0.2;
	    if (loss2 < 0.0) loss2 = 0.0;
	    break;
	default:
	    logMessage(5, "Unrecognised modal plate number %d in instrument file", type);
	    return false;
	}
	
	GlobalSettings::getInstance()->setSampleRate(fs);
	GlobalSettings::getInstance()->setResampleOuts(true);
	
	ModalPlate *mp = new ModalPlate("modalplate", A, lx, ly, h, nu, E, rho,
					loss1, loss2, halfNyquist);
	instrument->addComponent(mp);
	return true;
    }

    // check we have all required values
    if ((nu < 0.0) || (rho < 0.0) || (E < 0.0) || (h < 0.0) || (lx < 0.0) ||
	(ly < 0.0) || (A < 0.0)) {
	logMessage(5, "Modal plate definition is missing required value");
	return false;
    }

    GlobalSettings::getInstance()->setResampleOuts(true);

    ModalPlate *mp = new ModalPlate(name, A, lx, ly, h, nu, E, rho, loss1, loss2,
				    halfNyquist);
    instrument->addComponent(mp);
    return true;
}

bool InstrumentParserXML::parseBowParameters(xmlNodePtr node, double &Kw, double &alpha, double &beta, double &lambda, double &M)
{
    BEGIN_PROPERTIES("bowParameters");
    DOUBLE_PROPERTY("Kw", Kw);
    DOUBLE_PROPERTY("alpha", alpha);
    DOUBLE_PROPERTY("beta", beta);
    DOUBLE_PROPERTY("lambda", lambda);
    DOUBLE_PROPERTY("M", M);
    END_PROPERTIES;
    return true;
}

bool InstrumentParserXML::parseFingerParameters(xmlNodePtr node, double &Kw, double &Ku, double &alpha, double &beta, double &lambda, double &M)
{
    BEGIN_PROPERTIES("bowParameters");
    DOUBLE_PROPERTY("Kw", Kw);
    DOUBLE_PROPERTY("Ku", Ku);
    DOUBLE_PROPERTY("alpha", alpha);
    DOUBLE_PROPERTY("beta", beta);
    DOUBLE_PROPERTY("lambda", lambda);
    DOUBLE_PROPERTY("M", M);
    END_PROPERTIES;
    return true;
}

bool InstrumentParserXML::parseBowedString(xmlNodePtr node, BowedString **result)
{
    double L = -1.0, E = -1.0, radius = -1.0, rho = -1.0, T60_0 = -1.0;
    double T60_1000 = -1.0, f0 = -1.0;
    int instrument_index = -1;

    double KwB = 1e6, alphaB = 2.0, betaB = 20.0, lambdaB = 10.0, MB = 0.1;
    double KwF = 1e5, KuF = 1e3, alphaF = 2.2, betaF = 50.0, lambdaF = 20.0, MF = 0.05;

    BowedString *bs;

    int i;

    bool bowParams = false, fingerParams = false;

    // get name attribute, which must be present
    NAME_ATTRIBUTE("bowedString");

    // parse the required properties
    BEGIN_PROPERTIES("bowedString");
    DOUBLE_PROPERTY("length", L);
    DOUBLE_PROPERTY("youngsModulus", E);
    DOUBLE_PROPERTY("radius", radius);
    DOUBLE_PROPERTY("density", rho);
    DOUBLE_PROPERTY("T60_0", T60_0);
    DOUBLE_PROPERTY("T60_1000", T60_1000);
    DOUBLE_PROPERTY("frequency", f0);
    INT_PROPERTY("instrumentIndex", instrument_index);
    STRING_PROPERTY("instrumentType", matname);
    if (!xmlStrcmp(child->name, (const xmlChar *)"bowParameters")) {
	if (!parseBowParameters(child, KwB, alphaB, betaB, lambdaB, MB)) {
	    return false;
	}
	bowParams = true;
    }
    if (!xmlStrcmp(child->name, (const xmlChar *)"fingerParameters")) {
	if (!parseFingerParameters(child, KwF, KuF, alphaF, betaF, lambdaF, MF)) {
	    return false;
	}
	fingerParams = true;
    }
    END_PROPERTIES;

    if (matname) {
	// whole pre-defined instrument
	if (instrument_index < 0) {
	    logMessage(5, "Bowed string instrument definition is missing instrumentIndex");
	    free(matname);
	    return false;
	}

	// adjust index to base zero
	instrument_index--;

	// create four strings
	for (i = 0; i < 4; i++) {
	    char namebuf[20];
	    sprintf(namebuf, "%s%d", name.c_str(), i+1);
	    bs = new BowedString(namebuf, matname, instrument_index, i);
	    if (bowParams) {
		bs->setBowParameters(KwB, alphaB, betaB, lambdaB, MB);
	    }
	    if (fingerParams) {
		bs->setFingerParameters(KwF, KuF, alphaF, betaF, lambdaF, MF);
	    }
	    instrument->addComponent(bs);
	}
	free(matname);
    }
    else {
	// single string with individual numerical properties
	if ((L < 0.0) || (E < 0.0) || (radius < 0.0) || (rho < 0.0) || (T60_0 < 0.0) ||
	    (T60_1000 < 0.0) || (f0 < 0.0)) {
	    logMessage(5, "Bowed string definition is missing a required value");
	    return false;
	}
	bs = new BowedString(name, f0, rho, radius, E, T60_0, T60_1000, L);
	if (bowParams) {
	    bs->setBowParameters(KwB, alphaB, betaB, lambdaB, MB);
	}
	if (fingerParams) {
	    bs->setFingerParameters(KwF, KuF, alphaF, betaF, lambdaF, MF);
	}
	instrument->addComponent(bs);
	if (result) *result = bs;
    }
    return true;
}

bool InstrumentParserXML::parseBar(xmlNodePtr node)
{
    double L = -1.0, H0 = -1.0;
    int bc = 1;
    double E = -1.0, rho_0 = -1.0;

    // get name attribute, which must be present
    NAME_ATTRIBUTE("bar");

    // parse the required properties
    BEGIN_PROPERTIES("bar");
    DOUBLE_PROPERTY("length", L);
    DOUBLE_PROPERTY("width", H0);
    DOUBLE_PROPERTY("density", rho_0);
    DOUBLE_PROPERTY("youngsModulus", E);
    INT_PROPERTY("boundaryCondition", bc);
    STRING_PROPERTY("material", matname);
    DOUBLE_SETTING("fixpar", "fixpar");
    END_PROPERTIES;

    // check we have everything needed
    if ((L < 0.0) || (H0 < 0.0)) {
	logMessage(5, "Bar definition is missing required value");
	if (matname) free(matname);
	return false;
    }

    Bar *bar;
    if (matname) {
	Material *material = MaterialsManager::getInstance()->getMaterial(matname);
	if (!material) {
	    logMessage(5, "Material %s not found", matname);
	    free(matname);
	    return false;
	}	
	free(matname);
	bar = new Bar(name, material, L, H0, bc);
    }
    else {
	if ((E < 0.0) || (rho_0 < 0.0)) {
	    logMessage(5, "Bar definition is missing required value");
	    return false;
	}
	bar = new Bar(name, E, rho_0, L, H0, bc);
    }
    instrument->addComponent(bar);

    return true;
}


bool InstrumentParserXML::parseFretboard(xmlNodePtr node)
{
    double L = -1.0, rho = -1.0, T = -1.0, E = -1.0, r = -1.0;
    double T60_0 = -1.0, T60_1000 = -1.0;
    int numFrets = -1, iterations = 15;
    double b0 = 1.0, b1 = 1.0, fretHeight = 1.0;
    double K = -1.0, alpha = -1.0, beta = -1.0;

    // get name attribute, which must be present
    NAME_ATTRIBUTE("fretboard");

    // basic properties
    BEGIN_PROPERTIES("fretboard");
    DOUBLE_PROPERTY("length", L);
    DOUBLE_PROPERTY("density", rho);
    DOUBLE_PROPERTY("tension", T);
    DOUBLE_PROPERTY("youngsModulus", E);
    DOUBLE_PROPERTY("radius", r);
    DOUBLE_PROPERTY("t60_0", T60_0);
    DOUBLE_PROPERTY("t60_1000", T60_1000);
    INT_PROPERTY("numFrets", numFrets);
    DOUBLE_PROPERTY("barrierHeight", b0);
    DOUBLE_PROPERTY("barrierCurvature", b1);
    DOUBLE_PROPERTY("fretHeight", fretHeight);
    DOUBLE_PROPERTY("K", K);
    DOUBLE_PROPERTY("alpha", alpha);
    DOUBLE_PROPERTY("beta", beta);
    INT_PROPERTY("iterations", iterations);
    END_PROPERTIES;

    // Check we have all the essentials
    if ((L < 0.0) || (rho < 0.0) || (T < 0.0) || (E < 0.0) || (r < 0.0) ||
	(T60_0 < 0.0) || (T60_1000 < 0.0) || (numFrets < 0) || (b0 > 0.0) ||
	(b1 > 0.0) || (fretHeight > 0.0) || (K < 0.0) || (alpha < 0.0) ||
	(beta < 0.0)) {
	logMessage(5, "Fretboard definition is missing a required value");
	return false;
    }

    Fretboard *fb = new Fretboard(name, L, E, T, r, rho, T60_0, T60_1000, numFrets,
				  b0, b1, fretHeight, K, alpha, beta, iterations);
    instrument->addComponent(fb);
    return true;
}

bool InstrumentParserXML::parseComponentString(xmlNodePtr node, ComponentString **result)
{
    double L = -1.0, rho = -1.0, T = -1.0, E = -1.0, r = -1.0;
    double T60_0 = -1.0, T60_1000 = -1.0;
    double x1 = 0.0, y1 = 0.0, x2 = 0.0, y2 = 0.0;

    int numFrets = 0;
    double fretHeight = 1.0;
    double backboardHeight = 1.0;
    double backboardVar = -1.0;

    double k = -1.0, alpha = -1.0;
    int iterations = -1;

    // get name attribute, which must be present
    NAME_ATTRIBUTE("string");

    // basic properties
    BEGIN_PROPERTIES("string");
    DOUBLE_PROPERTY("length", L);
    DOUBLE_PROPERTY("density", rho);
    DOUBLE_PROPERTY("tension", T);
    DOUBLE_PROPERTY("youngsModulus", E);
    DOUBLE_PROPERTY("radius", r);
    DOUBLE_PROPERTY("t60_0", T60_0);
    DOUBLE_PROPERTY("t60_1000", T60_1000);

    // attachment to soundboard
    DOUBLE_PROPERTY("x1", x1);
    DOUBLE_PROPERTY("y1", y1);
    DOUBLE_PROPERTY("x2", x2);
    DOUBLE_PROPERTY("y2", y2);

    // frets
    INT_PROPERTY("numFrets", numFrets);
    DOUBLE_PROPERTY("fretHeight", fretHeight);
    DOUBLE_PROPERTY("backboardHeight", backboardHeight);
    DOUBLE_PROPERTY("backboardVariation", backboardVar);
    DOUBLE_PROPERTY("k", k);
    DOUBLE_PROPERTY("alpha", alpha);
    INT_PROPERTY("iterations", iterations);
    END_PROPERTIES;

    // Check we have all the essentials
    if ((L < 0.0) || (rho < 0.0) || (T < 0.0) || (E < 0.0) || (r < 0.0) ||
	(T60_0 < 0.0) || (T60_1000 < 0.0)) {
	logMessage(5, "String definition is missing a required value");
	return false;
    }

    ComponentString *str;
    // see if we have frets or not
    if (numFrets == 0) {
	str = new ComponentString(name, L, rho, T, E, r, T60_0, T60_1000, x1, y1,
				  x2, y2);
    }
    else {
	if ((fretHeight > 0.0) || (backboardHeight > 0.0) || (backboardVar < 0.0) ||
	    (k < 0.0) || (alpha < 0.0) || (iterations < 0)) {
	    logMessage(5, "String with frets definition is missing a required value");
	    return false;
	}

	StringWithFrets *swf = new StringWithFrets(name, L, rho, T, E, r, T60_0, T60_1000,
						   x1, y1, x2, y2, numFrets, fretHeight,
						   backboardHeight, backboardVar);
	swf->setParams(k, alpha, iterations);
	str = swf;
    }
    instrument->addComponent(str);
    if (result) *result = str;
    return true;
}

bool InstrumentParserXML::parsePlateEmbedded(xmlNodePtr node, Airbox *airbox, bool isMembrane)
{
    // basic dimensions
    double lx = -1.0, ly = -1.0, cx = -1000000.0, cy = -1000000.0, cz = -1000000.0;
    double radius = -1.0;

    // material type stuff
    double nu = -1.0, rho = -1.0, E = -1.0, thickness = -1.0, tension = 0.0;
    double T60 = -1.0, sig1 = -1.0;
    bool circular = false;  // will be set if has radius instead of lx and ly

    // get name attribute, which must be present
    NAME_ATTRIBUTE("embedded plate/membrane");

    BEGIN_PROPERTIES("embedded plate/membrane");
    STRING_PROPERTY("material", matname);
    DOUBLE_PROPERTY("poissonsRatio", nu);
    DOUBLE_PROPERTY("density", rho);
    DOUBLE_PROPERTY("youngsModulus", E);
    DOUBLE_PROPERTY("thickness", thickness);
    DOUBLE_PROPERTY("tension", tension);
    DOUBLE_PROPERTY("lx", lx);
    DOUBLE_PROPERTY("ly", ly);
    DOUBLE_PROPERTY("cx", cx);
    DOUBLE_PROPERTY("cy", cy);
    DOUBLE_PROPERTY("cz", cz);
    DOUBLE_PROPERTY("radius", radius);
    DOUBLE_PROPERTY("t60", T60);
    DOUBLE_PROPERTY("sig1", sig1);

    BOOL_SETTING("linear", "linear");
    BOOL_SETTING("symmetric", "symmetric");
    INT_SETTING("iterinv", "iterinv");
    DOUBLE_SETTING("fixpar", "fixpar");
    INT_SETTING("lossMode", "loss_mode");
    DOUBLE_SETTING("pcgTolerance", "pcg_tolerance");
    INT_SETTING("pcgMaxIterations", "pcg_max_it");
    END_PROPERTIES;

    if (radius > 0.0) {
	lx = radius;
	ly = radius;
	circular = true;
    }

    // check we have all required values
    if ((thickness < 0.0) || (lx < 0.0) || (ly < 0.0) || (T60 < 0.0) || (sig1 < 0.0) ||
	(cx < -100000.0) || (cy < -100000.0) || (cz < -100000.0)) {
	logMessage(5, "Embedded plate/membrane definition is missing required value");
	if (matname) free(matname);
	return false;
    }

    // check for material or other values
    // and create the plate
    PlateEmbedded *plate;
    if (matname) {
	Material *material = MaterialsManager::getInstance()->getMaterial(matname);
	if (!material) {
	    logMessage(5, "Material %s not found", matname);
	    free(matname);
	    return false;
	}
	free(matname);

	plate = new PlateEmbedded(name, material, thickness, tension, lx, ly, T60, sig1, cx, cy, cz,
				  isMembrane, circular);
    }
    else {
	if ((nu < 0.0) || (rho < 0.0) || (E < 0.0)) {
	    logMessage(5, "Embedded plate/membrane definition is missing required value");
	    return false;
	}

	plate = new PlateEmbedded(name, nu, rho, E, thickness, tension, lx, ly, T60, sig1, cx, cy, cz,
				  isMembrane, circular);
    }
    instrument->addComponent(plate);
    if (airbox) {
	instrument->addConnection(new Embedding(airbox, plate));
    }

    return true;
}

bool InstrumentParserXML::parseDrumShell(xmlNodePtr node, AirboxIndexed *airbox)
{
    double cx = -1.0, cy = -1.0, bz = -1.0, R = -1.0, H_shell = -1.0;

    BEGIN_PROPERTIES("drum shell");
    DOUBLE_PROPERTY("centreX", cx);
    DOUBLE_PROPERTY("centreY", cy);
    DOUBLE_PROPERTY("bottomZ", bz);
    DOUBLE_PROPERTY("radius", R);
    DOUBLE_PROPERTY("height", H_shell);
    END_PROPERTIES;

    // check we got all the values we need
    if ((cx < 0.0) || (cy < 0.0) || (bz < 0.0) || (R < 0.0) || (H_shell < 0.0)) {
	logMessage(5, "drum shell definition is missing required value");
	return false;
    }

    // actually create the drum shell
    airbox->addDrumShell(cx, cy, bz, R, H_shell);

    return true;
}

bool InstrumentParserXML::parseConnection(xmlNodePtr node)
{
    // generic connection items
    double x1 = -1.0, y1 = 0.0, z1 = 0.0;
    double x2 = -1.0, y2 = 0.0, z2 = 0.0;

    // Zero items
    double linearStiffness = -1.0;
    double nonLinearStiffness = -1.0;
    double t60 = -1.0;

    // ZeroPt1 items
    double K = -1.0, alpha = -1.0, oneSided = -1.0, offset = -1.0;

    int i;

    BEGIN_PROPERTIES("connection");
	if (!xmlStrcmp(child->name, (const xmlChar *)"component")) {
	    recognised = true;
	    if (!component1) {
		component1 = parseString(child);
	    }
	    else if (!component2) {
		component2 = parseString(child);
	    }
	    else {
		free(component1);
		free(component2);
		logMessage(5, "More than two components in a connection definition");
		return false;
	    }
	}
    DOUBLE_PROPERTY("x1", x1);
    DOUBLE_PROPERTY("y1", y1);
    DOUBLE_PROPERTY("z1", z1);
    DOUBLE_PROPERTY("x2", x2);
    DOUBLE_PROPERTY("y2", y2);
    DOUBLE_PROPERTY("z2", z2);
    DOUBLE_PROPERTY("linearStiffness", linearStiffness);
    DOUBLE_PROPERTY("nonLinearStiffness", nonLinearStiffness);
    DOUBLE_PROPERTY("t60", t60);
    DOUBLE_PROPERTY("k", K);
    DOUBLE_PROPERTY("alpha", alpha);
    DOUBLE_PROPERTY("oneSided", oneSided);
    DOUBLE_PROPERTY("offset", offset);
    END_PROPERTIES;

    // check for basics
    if ((!component1) || (!component2) || (x1 < 0.0) || (x2 < 0.0)) {
	logMessage(5, "Connection definition is missing required value");
	if (component1) free(component1);
	if (component2) free(component2);
	return false;
    }

    // find components
    Component *c1 = instrument->getComponentByName(component1);
    Component *c2 = instrument->getComponentByName(component2);
    if (!c1) {
	logMessage(5, "Unrecognised component name %s in connection definition",
		   component1);
	free(component1);
	free(component2);
	return false;
    }
    if (!c2) {
	logMessage(5, "Unrecognised component name %s in connection definition",
		   component2);
	free(component1);
	free(component2);
	return false;
    }

    // see which kind of connection we have
    ConnectionP2P *conn;
    if (linearStiffness >= 0.0) {
	// Zero-style
	// check we have everything we need
	if ((nonLinearStiffness < 0.0) || (t60 < 0.0)) {
	    logMessage(5, "Connection definition is missing required value");
	    free(component1);
	    free(component2);
	    return false;
	}
	conn = new ConnectionZero(c1, c2, x1, y1, z1, x2, y2, z2, linearStiffness,
				  nonLinearStiffness, t60);
    }
    else {
	// ZeroPt1-style
	// check we have everything we need
	if ((K < 0.0) || (alpha < 0.0) || (oneSided < 0.0) || (offset < 0.0)) {
	    logMessage(5, "Connection definition is missing required value");
	    free(component1);
	    free(component2);
	    return false;
	}
	conn = new ConnectionZeroPt1(c1, c2, x1, y1, z1, x2, y2, z2, K, alpha,
				     oneSided, offset);
    }

    // reject co-incident connections
    for (i = 0; i < p2pConnections.size(); i++) {
	if (p2pConnections[i]->coincides(conn)) {	
	    logMessage(5, "Deleting co-incident connection between %s and %s",
		       component1, component2);
	    delete conn;
	    free(component1);
	    free(component2);
	    // this isn't an error condition
	    return true;
	}
    } 
    free(component1);
    free(component2);   

    p2pConnections.push_back(conn);
    instrument->addConnection(conn);

    return true;
}

bool InstrumentParserXML::parsePlate(xmlNodePtr node)
{
    double nu = -1.0, rho = -1.0, E = -1.0, thickness = -1.0, tension = -1.0;
    double lx = -1.0, ly = -1.0, t60_0 = -1.0, t60_1000 = -1.0;

    // MP3D plate values
    double t60 = -1.0, sig1 = -1.0, cx = -1.0, cy = -1.0, cz = -1.0, radius = -1.0;

    int bc = 1;
    int i;

    // soundboards can have strings
    vector<ComponentString*> strings;

    // get name attribute, which must be present
    NAME_ATTRIBUTE("plate");

    BEGIN_PROPERTIES("plate");
    STRING_PROPERTY("material", matname);
    DOUBLE_PROPERTY("poissonsRatio", nu);
    DOUBLE_PROPERTY("density", rho);
    DOUBLE_PROPERTY("youngsModulus", E);
    DOUBLE_PROPERTY("thickness", thickness);
    DOUBLE_PROPERTY("tension", tension);
    DOUBLE_PROPERTY("lx", lx);
    DOUBLE_PROPERTY("ly", ly);
    DOUBLE_PROPERTY("t60_0", t60_0);
    DOUBLE_PROPERTY("t60_1000", t60_1000);

    DOUBLE_PROPERTY("t60", t60);
    DOUBLE_PROPERTY("sig1", sig1);
    DOUBLE_PROPERTY("cx", cx);
    DOUBLE_PROPERTY("cy", cy);
    DOUBLE_PROPERTY("cz", cz);
    DOUBLE_PROPERTY("radius", radius);

    INT_PROPERTY("boundaryCondition", bc);
    INT_SETTING("lossMode", "loss_mode");
    DOUBLE_SETTING("fixpar", "fixpar");
	if (!xmlStrcmp(child->name, (const xmlChar *)"string")) {
	    // string component attached to plate
	    ComponentString *str;
	    if (!parseComponentString(child, &str)) {
		if (matname) free(matname);
		return false;
	    }
	    // parseComponentString should add the string to the instrument
	    strings.push_back(str);
	}
    END_PROPERTIES;

    // is it MP3D type plate?
    if ((t60 >= 0.0) && (sig1 >= 0.0)) {
	PlateEmbedded *pe;
	bool circular = false;
	if (radius >= 0.0) {
	    circular = true;
	    lx = radius;
	    ly = radius;
	}
	if (matname) {
	    Material *material = MaterialsManager::getInstance()->getMaterial(matname);
	    if (!material) {
		logMessage(5, "Material %s not found", matname);
		free(matname);
		return false;
	    }
	    free(matname);
	    pe = new PlateEmbedded(name, material, thickness, tension, lx, ly, t60, sig1, cx,
						  cy, cz, false, circular);
	}
	else {
	    if ((nu < 0.0) || (rho < 0.0) || (E < 0.0)) {
		logMessage(5, "Plate definition is missing required value");
		return false;
	    }
	    pe = new PlateEmbedded(name, nu, rho, E, thickness, tension, lx, ly, t60, sig1, cx,
						  cy, cz, false, circular);
	}
	instrument->addComponent(pe);
	return true;
    }

    // check we have all required values
    if ((thickness < 0.0) || (tension < 0.0) || (lx < 0.0) || (ly < 0.0) || (t60_0 < 0.0) || (t60_1000 < 0.0)) {
	logMessage(5, "Plate definition is missing required value");
	if (matname) free(matname);
	return false;
    }

    // check for material or other values
    // and create the plate
    Plate *plate;
    if (matname) {
	Material *material = MaterialsManager::getInstance()->getMaterial(matname);
	if (!material) {
	    logMessage(5, "Material %s not found", matname);
	    free(matname);
	    return false;
	}
	free(matname);

	if (strings.size() == 0) {
	    // ordinary plate
	    plate = new Plate(name, material, thickness, tension, lx, ly, t60_0, t60_1000, bc);
	}
	else {
	    // soundboard needs a dynamically allocated vector of strings
	    vector<ComponentString*> *strings2 = new vector<ComponentString*>();
	    for (i = 0; i < strings.size(); i++) {
		strings2->push_back(strings[i]);
	    }
	    // soundboard
	    plate = new SoundBoard(name, material->getPoissonsRatio(), material->getDensity(),
				   material->getYoungsModulus(), thickness, tension, lx, ly, t60_0, t60_1000,
				   bc, strings2);
	}
    }
    else {
	if ((nu < 0.0) || (rho < 0.0) || (E < 0.0)) {
	    logMessage(5, "Plate definition is missing required value");
	    return false;
	}

	if (strings.size() == 0) {
	    // ordinary plate
	    plate = new Plate(name, nu, rho, E, thickness, tension, lx, ly, t60_0, t60_1000, bc);
	}
	else {
	    // soundboard needs a dynamically allocated vector of strings
	    vector<ComponentString*> *strings2 = new vector<ComponentString*>();
	    for (i = 0; i < strings.size(); i++) {
		strings2->push_back(strings[i]);
	    }
	    // soundboard
	    plate = new SoundBoard(name, nu, rho, E, thickness, tension, lx, ly, t60_0, t60_1000,
				   bc, strings2);
	}
    }

    instrument->addComponent(plate);

    return true;
}

bool InstrumentParserXML::parseAirbox(xmlNodePtr node)
{
    double lx=-1.0, ly=-1.0, lz=-1.0, c_a=-1.0, rho_a=-1.0;
    char *val;

    int i;
    vector<xmlNodePtr> subComponents;

    // get name attribute, which must be present
    NAME_ATTRIBUTE("airbox");

    BEGIN_PROPERTIES("airbox");
    DOUBLE_PROPERTY("lx", lx);
    DOUBLE_PROPERTY("ly", ly);
    DOUBLE_PROPERTY("lz", lz);
    DOUBLE_PROPERTY("c_a", c_a);
    DOUBLE_PROPERTY("rho_a", rho_a);
	if ((!xmlStrcmp(child->name, (const xmlChar *)"drumShell")) ||
	    (!xmlStrcmp(child->name, (const xmlChar *)"plate")) ||
	    (!xmlStrcmp(child->name, (const xmlChar *)"membrane"))) {
	    // save sub-components for later. They need to be done after the
	    // main airbox is created
	    subComponents.push_back(child);
	}
    END_PROPERTIES;

    // see if we got all the required values
    if ((lx < 0.0) || (ly < 0.0) || (lz < 0.0) || (c_a < 0.0) || (rho_a < 0.0)) {
	logMessage(5, "Airbox definition is missing required value");
	return false;
    }

    // actually create the airbox
    AirboxIndexed *airbox;
    airbox = new AirboxIndexed(name, lx, ly, lz, c_a, rho_a);
    instrument->addComponent(airbox);

    // now create sub-components
    for (i = 0; i < subComponents.size(); i++) {
	child = subComponents[i];
	if (!xmlStrcmp(child->name, (const xmlChar *)"drumShell")) {
	    if (!parseDrumShell(child, airbox)) {
		return false;
	    }
	}
	else if (!xmlStrcmp(child->name, (const xmlChar *)"plate")) {
	    if (!parsePlateEmbedded(child, airbox, false)) {
		return false;
	    }
	}
	else if (!xmlStrcmp(child->name, (const xmlChar *)"membrane")) {
	    if (!parsePlateEmbedded(child, airbox, true)) {
		return false;
	    }	    
	}
    }

    return true;
}

#endif
#endif

bool InstrumentParserXML::parseOutput(xmlNodePtr node)
{
    double pan = 0.0, x = -1.0, y = 0.0, z = 0.0;
    int type = 0; // normal
    int interpolated = -1;

    // check for type attribute
    xmlChar *xtype = xmlGetProp(node, (const xmlChar *)"type");
    if (xtype) {
	if (!xmlStrcmp(xtype, (const xmlChar *)"difference")) {
	    type = 1;
	}
	else if (!xmlStrcmp(xtype, (const xmlChar *)"pressure")) {
	    type = 2;
	}
	else if (xmlStrcmp(xtype, (const xmlChar *)"normal")) {
	    logMessage(5, "Unrecognised output type '%s', defaulting to 'normal'",
		       xtype);
	}
	xmlFree(xtype);
    }

    // allow interpolation to be turned on by attribute
    xmlChar *xinterp = xmlGetProp(node, (const xmlChar *)"interpolated");
    if (xinterp) {
	if (!xmlStrcmp(xinterp, (const xmlChar *)"true")) {
	    interpolated = 1;
	}
	else if (!xmlStrcmp(xinterp, (const xmlChar *)"false")) {
	    interpolated = 0;
	}
	else {
	    logMessage(5, "Invalid value '%s' for output interpolated attribute",
		       xinterp);
	    xmlFree(xinterp);
	    return false;
	}
	xmlFree(xinterp);
    }

    BEGIN_PROPERTIES("output");
    STRING_PROPERTY("component", component1);
    DOUBLE_PROPERTY("pan", pan);
    DOUBLE_PROPERTY("x", x);
    DOUBLE_PROPERTY("y", y);
    DOUBLE_PROPERTY("z", z);
    END_PROPERTIES;

    // see if we got all the required values
    if ((component1 == NULL) || (x < 0.0)) {
	logMessage(5, "Output definition is missing required value");
	if (component1) free(component1);
	return false;
    }

    // find the component
    Component *comp = instrument->getComponentByName(component1);
    if (!comp) {
	logMessage(5, "Unrecognised component name %s in output definition",
		   component1);
	free(component1);
	return false;
    }
    free(component1);

#ifndef GUITAR_ONLY
#ifndef BRASS_ONLY
    ModalPlate *mp = dynamic_cast<ModalPlate*>(comp);
    if (mp != NULL) type = 3;
#endif
#endif

    // actually create the output
    Output *output = NULL;
    switch (type) {
    case 0: output = new Output(comp, pan, x, y, z, interpolated); break;
    case 1: output = new OutputDifference(comp, pan, x, y, z, interpolated); break;
    case 2: output = new OutputPressure(comp, pan, x, y, z, interpolated); break;
#ifndef GUITAR_ONLY
#ifndef BRASS_ONLY
    case 3: output = new OutputModal(mp, pan, x, y); break;
#endif
#endif
    }
    instrument->addOutput(output);

    return true;
}

